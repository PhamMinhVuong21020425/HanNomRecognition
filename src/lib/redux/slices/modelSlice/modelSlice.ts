/* Core */
import { createSlice, type PayloadAction } from '@reduxjs/toolkit';

/* Instruments */
import { Model } from '@/entities/model.entity';
import {
  getAllModelsAsync,
  getModelsOfUserAsync,
  updateModelAsync,
  deleteModelAsync,
} from './thunkActions';

/* Types */
export interface ModelState {
  allModels: Model[];
  userModels: Model[];
  selDetectModel: Model | null;
  selClassifyModel: Model | null;
  status: 'idle' | 'loading' | 'failed';
}

const initialState: ModelState = {
  allModels: [],
  userModels: [],
  selDetectModel: null,
  selClassifyModel: null,
  status: 'idle',
} satisfies ModelState as ModelState;

export const modelSlice = createSlice({
  name: 'model',
  // `createSlice` will infer the state type from the `initialState` argument
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setSelDetectModel: (state, action: PayloadAction<Model | null>) => {
      state.selDetectModel = action.payload;
    },
    setSelClassifyModel: (state, action: PayloadAction<Model | null>) => {
      state.selClassifyModel = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      // getAllDatasetsAsync
      .addCase(getAllModelsAsync.pending, state => {
        state.status = 'loading';
      })
      .addCase(getAllModelsAsync.rejected, state => {
        state.status = 'failed';
      })
      .addCase(
        getAllModelsAsync.fulfilled,
        (state, action: PayloadAction<Model[]>) => {
          state.status = 'idle';
          state.allModels = action.payload;
        }
      )

      // getDatasetsOfUserAsync
      .addCase(getModelsOfUserAsync.pending, state => {
        state.status = 'loading';
      })
      .addCase(getModelsOfUserAsync.rejected, state => {
        state.status = 'failed';
      })
      .addCase(
        getModelsOfUserAsync.fulfilled,
        (state, action: PayloadAction<Model[]>) => {
          state.status = 'idle';
          state.userModels = action.payload;
        }
      )

      // updateModelAsync
      .addCase(updateModelAsync.pending, state => {
        state.status = 'loading';
      })
      .addCase(updateModelAsync.rejected, state => {
        state.status = 'failed';
      })
      .addCase(
        updateModelAsync.fulfilled,
        (state, action: PayloadAction<Model>) => {
          state.status = 'idle';
          const updatedModel = action.payload;
          const index = state.allModels.findIndex(
            model => model.id === updatedModel.id
          );
          if (index !== -1) {
            const { name, description, is_public } = updatedModel;
            state.allModels[index].name = name;
            state.allModels[index].description = description;
            state.allModels[index].is_public = is_public;
          }
        }
      )

      // deleteModelAsync
      .addCase(deleteModelAsync.pending, state => {
        state.status = 'loading';
      })
      .addCase(deleteModelAsync.rejected, state => {
        state.status = 'failed';
      })
      .addCase(
        deleteModelAsync.fulfilled,
        (state, action: PayloadAction<string | null>) => {
          state.status = 'idle';
          state.allModels = state.allModels.filter(
            model => model.id !== action.payload
          );
        }
      );
  },
});

export const { setSelDetectModel, setSelClassifyModel } = modelSlice.actions;

export const modelReducer = modelSlice.reducer;
